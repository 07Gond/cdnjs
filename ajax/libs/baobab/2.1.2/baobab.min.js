= helpers; const DEFAULTS ={// Should the tree handle its transactions on its own?
  autoCommit:true,//Should the transactions be handled asynchronously? asynchronous: true,//Should the tree's data be immutable?
  immutable: true,

  // Should the monkeys be lazy?
  lazyMonkeys: true,

  // Should the tree be persistent?
  persistent: true,

  // Should the tree's update be pure? pure: true,//Validation specifications validate: null,//Validation behavior 'rollback' or 'notify' validationBehavior: 'rollback'}update(path,operation){if (!type.operationType(operation.type))
      throw makeError(
        `Baobab.update:unknown operation type "${operation.type}".`,{operation: operation} );// If we couldn't solve the path, we throw
    if (!solvedPath)
      throw makeError('Baobab.update:could not solve the given path.', {
        path: solvedPath
      });

    // Read-only path?
    const monkeyPath = type.monkeyPath(this._monkeys, solvedPath);
    if (monkeyPath && solvedPath.length > monkeyPath.length)
      throw makeError('Baobab.update: attempting to update a read-only path.', {
        path: solvedPath
      });

    // We don't unset irrelevant paths if (operation.type === 'unset' && !exists) return}; Baobab.dynamicNode = Baobab.monkey; Baobab.Cursor = Cursor; Baobab.MonkeyDefinition = MonkeyDefinition; Baobab.Monkey = Monkey; Baobab.type = type; Baobab.helpers = helpers; Object.defineProperty(Baobab,'version',{value:'2.1.2'});



export default Baobab;
__ESCAPED_SOURCE_END_CLEAN_CSS__